# DP
# 아래방향 정삼각형을 타일로 덮는 방법은 4가지
# 1. 위쪽 정삼각형이랑 함께 마름모 타일로 덮기
# 2. 왼쪽 정삼각형이랑 함께 마름모 타일로 덮기
# 3. 오른쪽 정삼각형이랑 함꼐 마름모 타일로 덮기
# 4. 정삼각형 타일로 덮기

# 근데 직전 아래 방향 정삼각형에 3번 방법을 적용했다면, 현재의 아래 방향 정삼각형에 2번 방법을 적용할 수 없음.
# 즉, 가장 최근 아래 방향 정삼각형에 적용한 방법이 3번인지 여부가 다음 아래 방향 정삼각형 덮는 방법에 영향을 미치기 때문에 배열을 2개로 구분

# a[k] : k번째 아래 방향 정삼각형까지 덮고, k번째 아래 방향 정삼각형을 덮는 방법이 3번 방법인 경우
# b[k] : k번째 아래 방향 정삼각형까지 덮고, k번째 아래 방향 정삼각형을 덮는 방법이 3번 방법이 아닌 경우

def solution(n, tops):
    answer = 0
    MOD = 10007
    a = [0] * (n+1)
    b = [0] * (n+1)
    a[1] = 1
    if tops[0]:
        b[1] = 3
    else:
        b[1] = 2
        
    for k in range(2, n+1):
        if tops[k-1]: # 위에 삼각형이 있는 경우
            a[k] = (a[k-1] + b[k-1]) % MOD
            b[k] = (2 * a[k-1] + 3 * b[k-1]) % MOD
        else: # 위에 삼각형이 없는 경우 1번 방법을 사용할 수 없음
            a[k] = (a[k-1] + b[k-1]) % MOD
            b[k] = (a[k-1] + 2 * b[k-1]) % MOD
    
    answer = (a[n] + b[n]) % MOD
    
    return answer